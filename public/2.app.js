(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "./node_modules/react-minimal-pie-chart/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-minimal-pie-chart/dist/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"./node_modules/react/index.js\"), __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\")) :\n  undefined;\n}(this, function (exports, React, PropTypes) { 'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  var partialCircle = function partialCircle(cx, cy, r, start, end) {\n    var length = end - start;\n    if (length === 0) return [];\n    var fromX = r * Math.cos(start) + cx;\n    var fromY = r * Math.sin(start) + cy;\n    var toX = r * Math.cos(end) + cx;\n    var toY = r * Math.sin(end) + cy;\n    var large = Math.abs(length) <= Math.PI ? '0' : '1';\n    var sweep = length < 0 ? '0' : '1';\n    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n  };\n\n  var svgPartialCircle = partialCircle;\n\n  var PI = Math.PI;\n  function degreesToRadians(degrees) {\n    return degrees * PI / 180;\n  }\n  function evaluateViewBoxSize(ratio, baseSize) {\n    // Wide ratio\n    if (ratio > 1) {\n      return \"0 0 \" + baseSize + \" \" + baseSize / ratio;\n    } // Narrow/squared ratio\n\n\n    return \"0 0 \" + baseSize * ratio + \" \" + baseSize;\n  }\n  function evaluateLabelTextAnchor(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        labelPosition = _ref.labelPosition,\n        lineWidth = _ref.lineWidth,\n        labelHorizontalShift = _ref.labelHorizontalShift;\n\n    // Label in the vertical center\n    if (labelHorizontalShift === 0) {\n      return 'middle';\n    } // Outward label\n\n\n    if (labelPosition > 100) {\n      return labelHorizontalShift > 0 ? 'start' : 'end';\n    } // Inward label\n\n\n    var innerRadius = 100 - lineWidth;\n\n    if (labelPosition < innerRadius) {\n      return labelHorizontalShift > 0 ? 'end' : 'start';\n    } // Overlying label\n\n\n    return 'middle';\n  }\n  function valueBetween(value, min, max) {\n    if (value > max) return max;\n    if (value < min) return min;\n    return value;\n  }\n  function extractPercentage(value, percentage) {\n    return value * percentage / 100;\n  }\n\n  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n    return svgPartialCircle(cx, cy, // center X and Y\n    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n      return command.join(' ');\n    }).join(' ');\n  }\n\n  function ReactMinimalPieChartPath(_ref) {\n    var cx = _ref.cx,\n        cy = _ref.cy,\n        startAngle = _ref.startAngle,\n        lengthAngle = _ref.lengthAngle,\n        radius = _ref.radius,\n        lineWidth = _ref.lineWidth,\n        reveal = _ref.reveal,\n        title = _ref.title,\n        props = _objectWithoutPropertiesLoose(_ref, [\"cx\", \"cy\", \"startAngle\", \"lengthAngle\", \"radius\", \"lineWidth\", \"reveal\", \"title\"]);\n\n    var actualRadio = radius - lineWidth / 2;\n    var pathCommands = makePathCommands(cx, cy, startAngle, lengthAngle, actualRadio);\n    var strokeDasharray;\n    var strokeDashoffset; // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n    // https://css-tricks.com/svg-line-animation-works/\n\n    if (typeof reveal === 'number') {\n      var pathLength = degreesToRadians(actualRadio) * lengthAngle;\n      strokeDasharray = Math.abs(pathLength);\n      strokeDashoffset = pathLength - extractPercentage(pathLength, reveal);\n    }\n\n    return React__default.createElement(\"path\", _extends({\n      d: pathCommands,\n      strokeWidth: lineWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset\n    }, props), title && React__default.createElement(\"title\", null, title));\n  }\n  ReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';\n  ReactMinimalPieChartPath.propTypes = {\n    cx: PropTypes.number.isRequired,\n    cy: PropTypes.number.isRequired,\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    radius: PropTypes.number,\n    lineWidth: PropTypes.number,\n    reveal: PropTypes.number,\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n  };\n  ReactMinimalPieChartPath.defaultProps = {\n    startAngle: 0,\n    lengthAngle: 0,\n    lineWidth: 100,\n    radius: 100\n  };\n\n  var stylePropType = PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]));\n  var dataPropType = PropTypes.arrayOf(PropTypes.shape({\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    value: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    style: stylePropType\n  }));\n\n  function ReactMinimalPieChartLabel(_ref) {\n    var data = _ref.data,\n        dataIndex = _ref.dataIndex,\n        color = _ref.color,\n        props = _objectWithoutPropertiesLoose(_ref, [\"data\", \"dataIndex\", \"color\"]);\n\n    return React__default.createElement(\"text\", _extends({\n      textAnchor: \"middle\",\n      dominantBaseline: \"middle\",\n      fill: color\n    }, props));\n  }\n  ReactMinimalPieChartLabel.displayName = 'ReactMinimalPieChartLabel';\n  ReactMinimalPieChartLabel.propTypes = {\n    data: dataPropType,\n    dataIndex: PropTypes.number,\n    color: PropTypes.string\n  };\n\n  var VIEWBOX_SIZE = 100;\n  var VIEWBOX_HALF_SIZE = VIEWBOX_SIZE / 2;\n\n  function sumValues(data) {\n    return data.reduce(function (acc, dataEntry) {\n      return acc + dataEntry.value;\n    }, 0);\n  } // Append \"percentage\", \"degrees\" and \"startOffset\" into each data entry\n\n\n  function extendData(_ref) {\n    var data = _ref.data,\n        totalAngle = _ref.lengthAngle,\n        totalValue = _ref.totalValue,\n        paddingAngle = _ref.paddingAngle;\n    var total = totalValue || sumValues(data);\n    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n    var lastSegmentEnd = 0;\n    return data.map(function (dataEntry) {\n      var valueInPercentage = dataEntry.value / total * 100;\n      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n      var startOffset = lastSegmentEnd;\n      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n      return _extends({\n        percentage: valueInPercentage,\n        degrees: degrees,\n        startOffset: startOffset\n      }, dataEntry);\n    });\n  }\n\n  function makeSegmentTransitionStyle(duration, easing, furtherStyles) {\n    if (furtherStyles === void 0) {\n      furtherStyles = {};\n    }\n\n    // Merge CSS transition necessary for chart animation with the ones provided by \"segmentsStyle\"\n    var transition = [\"stroke-dashoffset \" + duration + \"ms \" + easing, furtherStyles.transition].filter(Boolean).join(',');\n    return {\n      transition: transition\n    };\n  }\n\n  function renderLabelItem(option, props, value) {\n    if (React__default.isValidElement(option)) {\n      return React__default.cloneElement(option, props);\n    }\n\n    var label = value;\n\n    if (typeof option === 'function') {\n      label = option(props);\n\n      if (React__default.isValidElement(label)) {\n        return label;\n      }\n    }\n\n    return React__default.createElement(ReactMinimalPieChartLabel, props, label);\n  }\n\n  function renderLabels(data, props) {\n    var labelPosition = extractPercentage(props.radius, props.labelPosition);\n    return data.map(function (dataEntry, index) {\n      var startAngle = props.startAngle + dataEntry.startOffset;\n      var halfAngle = startAngle + dataEntry.degrees / 2;\n      var halfAngleRadians = degreesToRadians(halfAngle);\n      var dx = Math.cos(halfAngleRadians) * labelPosition;\n      var dy = Math.sin(halfAngleRadians) * labelPosition; // This object is passed as props to the \"label\" component\n\n      var labelProps = {\n        key: \"label-\" + (dataEntry.key || index),\n        x: props.cx,\n        y: props.cy,\n        dx: dx,\n        dy: dy,\n        textAnchor: evaluateLabelTextAnchor({\n          lineWidth: props.lineWidth,\n          labelPosition: props.labelPosition,\n          labelHorizontalShift: dx\n        }),\n        data: data,\n        dataIndex: index,\n        color: dataEntry.color,\n        style: props.labelStyle\n      };\n      return renderLabelItem(props.label, labelProps, dataEntry.value);\n    });\n  }\n\n  function renderSegments(data, props, hide) {\n    var style = props.segmentsStyle;\n    var reveal;\n\n    if (props.animate) {\n      var transitionStyle = makeSegmentTransitionStyle(props.animationDuration, props.animationEasing, style);\n      style = Object.assign({}, style, transitionStyle);\n    } // Hide/reveal the segment?\n\n\n    if (hide === true) {\n      reveal = 0;\n    } else if (typeof props.reveal === 'number') {\n      reveal = props.reveal;\n    } else if (hide === false) {\n      reveal = 100;\n    }\n\n    var paths = data.map(function (dataEntry, index) {\n      var startAngle = props.startAngle + dataEntry.startOffset;\n      return React__default.createElement(ReactMinimalPieChartPath, {\n        key: dataEntry.key || index,\n        cx: props.cx,\n        cy: props.cy,\n        startAngle: startAngle,\n        lengthAngle: dataEntry.degrees,\n        radius: props.radius,\n        lineWidth: extractPercentage(props.radius, props.lineWidth),\n        reveal: reveal,\n        title: dataEntry.title,\n        style: Object.assign({}, style, dataEntry.style),\n        stroke: dataEntry.color,\n        strokeLinecap: props.rounded ? 'round' : undefined,\n        fill: \"none\",\n        onMouseOver: props.onMouseOver && function (e) {\n          return props.onMouseOver(e, props.data, index);\n        },\n        onMouseOut: props.onMouseOut && function (e) {\n          return props.onMouseOut(e, props.data, index);\n        },\n        onClick: props.onClick && function (e) {\n          return props.onClick(e, props.data, index);\n        }\n      });\n    });\n\n    if (props.background) {\n      paths.unshift(React__default.createElement(ReactMinimalPieChartPath, {\n        key: \"bg\",\n        cx: props.cx,\n        cy: props.cy,\n        startAngle: props.startAngle,\n        lengthAngle: props.lengthAngle,\n        radius: props.radius,\n        lineWidth: extractPercentage(props.radius, props.lineWidth),\n        stroke: props.background,\n        strokeLinecap: props.rounded ? 'round' : undefined,\n        fill: \"none\"\n      }));\n    }\n\n    return paths;\n  }\n\n  var ReactMinimalPieChart =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(ReactMinimalPieChart, _Component);\n\n    function ReactMinimalPieChart(props) {\n      var _this;\n\n      _this = _Component.call(this, props) || this;\n\n      if (_this.props.animate === true) {\n        _this.hideSegments = true;\n      }\n\n      return _this;\n    }\n\n    var _proto = ReactMinimalPieChart.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.animate === true && requestAnimationFrame) {\n        this.initialAnimationTimerId = setTimeout(function () {\n          _this2.initialAnimationTimerId = null;\n          _this2.initialAnimationRAFId = requestAnimationFrame(function () {\n            _this2.initialAnimationRAFId = null;\n\n            _this2.startAnimation();\n          });\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this.initialAnimationTimerId) {\n        clearTimeout(this.initialAnimationTimerId);\n      }\n\n      if (this.initialAnimationRAFId) {\n        cancelAnimationFrame(this.initialAnimationRAFId);\n      }\n    };\n\n    _proto.startAnimation = function startAnimation() {\n      this.hideSegments = false;\n      this.forceUpdate();\n    };\n\n    _proto.render = function render() {\n      if (this.props.data === undefined) {\n        return null;\n      }\n\n      var extendedData = extendData(this.props);\n      return React__default.createElement(\"div\", {\n        className: this.props.className,\n        style: this.props.style\n      }, React__default.createElement(\"svg\", {\n        viewBox: evaluateViewBoxSize(this.props.ratio, VIEWBOX_SIZE),\n        width: \"100%\",\n        height: \"100%\",\n        style: {\n          display: 'block'\n        }\n      }, renderSegments(extendedData, this.props, this.hideSegments), this.props.label && renderLabels(extendedData, this.props), this.props.injectSvg && this.props.injectSvg()), this.props.children);\n    };\n\n    return ReactMinimalPieChart;\n  }(React.Component);\n  ReactMinimalPieChart.displayName = 'ReactMinimalPieChart';\n  ReactMinimalPieChart.propTypes = {\n    data: dataPropType,\n    cx: PropTypes.number,\n    cy: PropTypes.number,\n    ratio: PropTypes.number,\n    totalValue: PropTypes.number,\n    className: PropTypes.string,\n    style: stylePropType,\n    segmentsStyle: stylePropType,\n    background: PropTypes.string,\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    paddingAngle: PropTypes.number,\n    lineWidth: PropTypes.number,\n    radius: PropTypes.number,\n    rounded: PropTypes.bool,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    animationEasing: PropTypes.string,\n    reveal: PropTypes.number,\n    children: PropTypes.node,\n    injectSvg: PropTypes.func,\n    label: PropTypes.oneOfType([PropTypes.func, PropTypes.element, PropTypes.bool]),\n    labelPosition: PropTypes.number,\n    labelStyle: stylePropType,\n    onMouseOver: PropTypes.func,\n    onMouseOut: PropTypes.func,\n    onClick: PropTypes.func\n  };\n  ReactMinimalPieChart.defaultProps = {\n    cx: VIEWBOX_HALF_SIZE,\n    cy: VIEWBOX_HALF_SIZE,\n    ratio: 1,\n    startAngle: 0,\n    lengthAngle: 360,\n    paddingAngle: 0,\n    lineWidth: 100,\n    radius: VIEWBOX_HALF_SIZE,\n    rounded: false,\n    animate: false,\n    animationDuration: 500,\n    animationEasing: 'ease-out',\n    label: false,\n    labelPosition: 50,\n    onMouseOver: undefined,\n    onMouseOut: undefined,\n    onClick: undefined\n  };\n\n  exports.default = ReactMinimalPieChart;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbWluaW1hbC1waWUtY2hhcnQvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1taW5pbWFsLXBpZS1jaGFydC9kaXN0L2luZGV4LmpzPzkyMjQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdwcm9wLXR5cGVzJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCcsICdwcm9wLXR5cGVzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdE1pbmltYWxQaWVDaGFydCA9IHt9LCBnbG9iYWwuUmVhY3QsIGdsb2JhbC5Qcm9wVHlwZXMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0LCBQcm9wVHlwZXMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBSZWFjdF9fZGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBSZWFjdCA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcbiAgUHJvcFR5cGVzID0gUHJvcFR5cGVzICYmIFByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gUHJvcFR5cGVzWydkZWZhdWx0J10gOiBQcm9wVHlwZXM7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2YXIgcGFydGlhbENpcmNsZSA9IGZ1bmN0aW9uIHBhcnRpYWxDaXJjbGUoY3gsIGN5LCByLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICB2YXIgZnJvbVggPSByICogTWF0aC5jb3Moc3RhcnQpICsgY3g7XG4gICAgdmFyIGZyb21ZID0gciAqIE1hdGguc2luKHN0YXJ0KSArIGN5O1xuICAgIHZhciB0b1ggPSByICogTWF0aC5jb3MoZW5kKSArIGN4O1xuICAgIHZhciB0b1kgPSByICogTWF0aC5zaW4oZW5kKSArIGN5O1xuICAgIHZhciBsYXJnZSA9IE1hdGguYWJzKGxlbmd0aCkgPD0gTWF0aC5QSSA/ICcwJyA6ICcxJztcbiAgICB2YXIgc3dlZXAgPSBsZW5ndGggPCAwID8gJzAnIDogJzEnO1xuICAgIHJldHVybiBbWydNJywgZnJvbVgsIGZyb21ZXSwgWydBJywgciwgciwgMCwgbGFyZ2UsIHN3ZWVwLCB0b1gsIHRvWV1dO1xuICB9O1xuXG4gIHZhciBzdmdQYXJ0aWFsQ2lyY2xlID0gcGFydGlhbENpcmNsZTtcblxuICB2YXIgUEkgPSBNYXRoLlBJO1xuICBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIFBJIC8gMTgwO1xuICB9XG4gIGZ1bmN0aW9uIGV2YWx1YXRlVmlld0JveFNpemUocmF0aW8sIGJhc2VTaXplKSB7XG4gICAgLy8gV2lkZSByYXRpb1xuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJldHVybiBcIjAgMCBcIiArIGJhc2VTaXplICsgXCIgXCIgKyBiYXNlU2l6ZSAvIHJhdGlvO1xuICAgIH0gLy8gTmFycm93L3NxdWFyZWQgcmF0aW9cblxuXG4gICAgcmV0dXJuIFwiMCAwIFwiICsgYmFzZVNpemUgKiByYXRpbyArIFwiIFwiICsgYmFzZVNpemU7XG4gIH1cbiAgZnVuY3Rpb24gZXZhbHVhdGVMYWJlbFRleHRBbmNob3IoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBsYWJlbFBvc2l0aW9uID0gX3JlZi5sYWJlbFBvc2l0aW9uLFxuICAgICAgICBsaW5lV2lkdGggPSBfcmVmLmxpbmVXaWR0aCxcbiAgICAgICAgbGFiZWxIb3Jpem9udGFsU2hpZnQgPSBfcmVmLmxhYmVsSG9yaXpvbnRhbFNoaWZ0O1xuXG4gICAgLy8gTGFiZWwgaW4gdGhlIHZlcnRpY2FsIGNlbnRlclxuICAgIGlmIChsYWJlbEhvcml6b250YWxTaGlmdCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH0gLy8gT3V0d2FyZCBsYWJlbFxuXG5cbiAgICBpZiAobGFiZWxQb3NpdGlvbiA+IDEwMCkge1xuICAgICAgcmV0dXJuIGxhYmVsSG9yaXpvbnRhbFNoaWZ0ID4gMCA/ICdzdGFydCcgOiAnZW5kJztcbiAgICB9IC8vIElud2FyZCBsYWJlbFxuXG5cbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAxMDAgLSBsaW5lV2lkdGg7XG5cbiAgICBpZiAobGFiZWxQb3NpdGlvbiA8IGlubmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gbGFiZWxIb3Jpem9udGFsU2hpZnQgPiAwID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgIH0gLy8gT3Zlcmx5aW5nIGxhYmVsXG5cblxuICAgIHJldHVybiAnbWlkZGxlJztcbiAgfVxuICBmdW5jdGlvbiB2YWx1ZUJldHdlZW4odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKHZhbHVlID4gbWF4KSByZXR1cm4gbWF4O1xuICAgIGlmICh2YWx1ZSA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdFBlcmNlbnRhZ2UodmFsdWUsIHBlcmNlbnRhZ2UpIHtcbiAgICByZXR1cm4gdmFsdWUgKiBwZXJjZW50YWdlIC8gMTAwO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVBhdGhDb21tYW5kcyhjeCwgY3ksIHN0YXJ0QW5nbGUsIGxlbmd0aEFuZ2xlLCByYWRpdXMpIHtcbiAgICB2YXIgcGF0Y2hlZExlbmd0aEFuZ2xlID0gdmFsdWVCZXR3ZWVuKGxlbmd0aEFuZ2xlLCAtMzU5Ljk5OSwgMzU5Ljk5OSk7XG4gICAgcmV0dXJuIHN2Z1BhcnRpYWxDaXJjbGUoY3gsIGN5LCAvLyBjZW50ZXIgWCBhbmQgWVxuICAgIHJhZGl1cywgZGVncmVlc1RvUmFkaWFucyhzdGFydEFuZ2xlKSwgZGVncmVlc1RvUmFkaWFucyhzdGFydEFuZ2xlICsgcGF0Y2hlZExlbmd0aEFuZ2xlKSkubWFwKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICByZXR1cm4gY29tbWFuZC5qb2luKCcgJyk7XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoKF9yZWYpIHtcbiAgICB2YXIgY3ggPSBfcmVmLmN4LFxuICAgICAgICBjeSA9IF9yZWYuY3ksXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICAgIGxlbmd0aEFuZ2xlID0gX3JlZi5sZW5ndGhBbmdsZSxcbiAgICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXMsXG4gICAgICAgIGxpbmVXaWR0aCA9IF9yZWYubGluZVdpZHRoLFxuICAgICAgICByZXZlYWwgPSBfcmVmLnJldmVhbCxcbiAgICAgICAgdGl0bGUgPSBfcmVmLnRpdGxlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImN4XCIsIFwiY3lcIiwgXCJzdGFydEFuZ2xlXCIsIFwibGVuZ3RoQW5nbGVcIiwgXCJyYWRpdXNcIiwgXCJsaW5lV2lkdGhcIiwgXCJyZXZlYWxcIiwgXCJ0aXRsZVwiXSk7XG5cbiAgICB2YXIgYWN0dWFsUmFkaW8gPSByYWRpdXMgLSBsaW5lV2lkdGggLyAyO1xuICAgIHZhciBwYXRoQ29tbWFuZHMgPSBtYWtlUGF0aENvbW1hbmRzKGN4LCBjeSwgc3RhcnRBbmdsZSwgbGVuZ3RoQW5nbGUsIGFjdHVhbFJhZGlvKTtcbiAgICB2YXIgc3Ryb2tlRGFzaGFycmF5O1xuICAgIHZhciBzdHJva2VEYXNob2Zmc2V0OyAvLyBBbmltYXRlL2hpZGUgcGF0aHMgd2l0aCBcInN0cm9rZS1kYXNoYXJyYXlcIiArIFwic3Ryb2tlLWRhc2hvZmZzZXRcIlxuICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc3ZnLWxpbmUtYW5pbWF0aW9uLXdvcmtzL1xuXG4gICAgaWYgKHR5cGVvZiByZXZlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgcGF0aExlbmd0aCA9IGRlZ3JlZXNUb1JhZGlhbnMoYWN0dWFsUmFkaW8pICogbGVuZ3RoQW5nbGU7XG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBNYXRoLmFicyhwYXRoTGVuZ3RoKTtcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQgPSBwYXRoTGVuZ3RoIC0gZXh0cmFjdFBlcmNlbnRhZ2UocGF0aExlbmd0aCwgcmV2ZWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgX2V4dGVuZHMoe1xuICAgICAgZDogcGF0aENvbW1hbmRzLFxuICAgICAgc3Ryb2tlV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldFxuICAgIH0sIHByb3BzKSwgdGl0bGUgJiYgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSk7XG4gIH1cbiAgUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoLmRpc3BsYXlOYW1lID0gJ1JlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aCc7XG4gIFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aC5wcm9wVHlwZXMgPSB7XG4gICAgY3g6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBjeTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHN0YXJ0QW5nbGU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbGVuZ3RoQW5nbGU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxpbmVXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgICByZXZlYWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKVxuICB9O1xuICBSZWFjdE1pbmltYWxQaWVDaGFydFBhdGguZGVmYXVsdFByb3BzID0ge1xuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgbGVuZ3RoQW5nbGU6IDAsXG4gICAgbGluZVdpZHRoOiAxMDAsXG4gICAgcmFkaXVzOiAxMDBcbiAgfTtcblxuICB2YXIgc3R5bGVQcm9wVHlwZSA9IFByb3BUeXBlcy5vYmplY3RPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpO1xuICB2YXIgZGF0YVByb3BUeXBlID0gUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB0aXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAga2V5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgc3R5bGU6IHN0eWxlUHJvcFR5cGVcbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0TWluaW1hbFBpZUNoYXJ0TGFiZWwoX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICBkYXRhSW5kZXggPSBfcmVmLmRhdGFJbmRleCxcbiAgICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImRhdGFcIiwgXCJkYXRhSW5kZXhcIiwgXCJjb2xvclwiXSk7XG5cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRleHRcIiwgX2V4dGVuZHMoe1xuICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgIGRvbWluYW50QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICBmaWxsOiBjb2xvclxuICAgIH0sIHByb3BzKSk7XG4gIH1cbiAgUmVhY3RNaW5pbWFsUGllQ2hhcnRMYWJlbC5kaXNwbGF5TmFtZSA9ICdSZWFjdE1pbmltYWxQaWVDaGFydExhYmVsJztcbiAgUmVhY3RNaW5pbWFsUGllQ2hhcnRMYWJlbC5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogZGF0YVByb3BUeXBlLFxuICAgIGRhdGFJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZ1xuICB9O1xuXG4gIHZhciBWSUVXQk9YX1NJWkUgPSAxMDA7XG4gIHZhciBWSUVXQk9YX0hBTEZfU0laRSA9IFZJRVdCT1hfU0laRSAvIDI7XG5cbiAgZnVuY3Rpb24gc3VtVmFsdWVzKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZGF0YUVudHJ5KSB7XG4gICAgICByZXR1cm4gYWNjICsgZGF0YUVudHJ5LnZhbHVlO1xuICAgIH0sIDApO1xuICB9IC8vIEFwcGVuZCBcInBlcmNlbnRhZ2VcIiwgXCJkZWdyZWVzXCIgYW5kIFwic3RhcnRPZmZzZXRcIiBpbnRvIGVhY2ggZGF0YSBlbnRyeVxuXG5cbiAgZnVuY3Rpb24gZXh0ZW5kRGF0YShfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHRvdGFsQW5nbGUgPSBfcmVmLmxlbmd0aEFuZ2xlLFxuICAgICAgICB0b3RhbFZhbHVlID0gX3JlZi50b3RhbFZhbHVlLFxuICAgICAgICBwYWRkaW5nQW5nbGUgPSBfcmVmLnBhZGRpbmdBbmdsZTtcbiAgICB2YXIgdG90YWwgPSB0b3RhbFZhbHVlIHx8IHN1bVZhbHVlcyhkYXRhKTtcbiAgICB2YXIgbm9ybWFsaXplZFRvdGFsQW5nbGUgPSB2YWx1ZUJldHdlZW4odG90YWxBbmdsZSwgLTM2MCwgMzYwKTtcbiAgICB2YXIgbnVtYmVyT2ZQYWRkaW5ncyA9IE1hdGguYWJzKG5vcm1hbGl6ZWRUb3RhbEFuZ2xlKSA9PT0gMzYwID8gZGF0YS5sZW5ndGggOiBkYXRhLmxlbmd0aCAtIDE7XG4gICAgdmFyIHNpbmdsZVBhZGRpbmdEZWdyZWVzID0gTWF0aC5hYnMocGFkZGluZ0FuZ2xlKSAqIE1hdGguc2lnbih0b3RhbEFuZ2xlKTtcbiAgICB2YXIgZGVncmVlc1Rha2VuQnlQYWRkaW5nID0gc2luZ2xlUGFkZGluZ0RlZ3JlZXMgKiBudW1iZXJPZlBhZGRpbmdzO1xuICAgIHZhciBkZWdyZWVzVGFrZW5CeVBhdGhzID0gbm9ybWFsaXplZFRvdGFsQW5nbGUgLSBkZWdyZWVzVGFrZW5CeVBhZGRpbmc7XG4gICAgdmFyIGxhc3RTZWdtZW50RW5kID0gMDtcbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGFFbnRyeSkge1xuICAgICAgdmFyIHZhbHVlSW5QZXJjZW50YWdlID0gZGF0YUVudHJ5LnZhbHVlIC8gdG90YWwgKiAxMDA7XG4gICAgICB2YXIgZGVncmVlcyA9IGV4dHJhY3RQZXJjZW50YWdlKGRlZ3JlZXNUYWtlbkJ5UGF0aHMsIHZhbHVlSW5QZXJjZW50YWdlKTtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IGxhc3RTZWdtZW50RW5kO1xuICAgICAgbGFzdFNlZ21lbnRFbmQgPSBsYXN0U2VnbWVudEVuZCArIGRlZ3JlZXMgKyBzaW5nbGVQYWRkaW5nRGVncmVlcztcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHBlcmNlbnRhZ2U6IHZhbHVlSW5QZXJjZW50YWdlLFxuICAgICAgICBkZWdyZWVzOiBkZWdyZWVzLFxuICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXRcbiAgICAgIH0sIGRhdGFFbnRyeSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2VnbWVudFRyYW5zaXRpb25TdHlsZShkdXJhdGlvbiwgZWFzaW5nLCBmdXJ0aGVyU3R5bGVzKSB7XG4gICAgaWYgKGZ1cnRoZXJTdHlsZXMgPT09IHZvaWQgMCkge1xuICAgICAgZnVydGhlclN0eWxlcyA9IHt9O1xuICAgIH1cblxuICAgIC8vIE1lcmdlIENTUyB0cmFuc2l0aW9uIG5lY2Vzc2FyeSBmb3IgY2hhcnQgYW5pbWF0aW9uIHdpdGggdGhlIG9uZXMgcHJvdmlkZWQgYnkgXCJzZWdtZW50c1N0eWxlXCJcbiAgICB2YXIgdHJhbnNpdGlvbiA9IFtcInN0cm9rZS1kYXNob2Zmc2V0IFwiICsgZHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nLCBmdXJ0aGVyU3R5bGVzLnRyYW5zaXRpb25dLmZpbHRlcihCb29sZWFuKS5qb2luKCcsJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxJdGVtKG9wdGlvbiwgcHJvcHMsIHZhbHVlKSB7XG4gICAgaWYgKFJlYWN0X19kZWZhdWx0LmlzVmFsaWRFbGVtZW50KG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jbG9uZUVsZW1lbnQob3B0aW9uLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0gdmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGFiZWwgPSBvcHRpb24ocHJvcHMpO1xuXG4gICAgICBpZiAoUmVhY3RfX2RlZmF1bHQuaXNWYWxpZEVsZW1lbnQobGFiZWwpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdE1pbmltYWxQaWVDaGFydExhYmVsLCBwcm9wcywgbGFiZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBleHRyYWN0UGVyY2VudGFnZShwcm9wcy5yYWRpdXMsIHByb3BzLmxhYmVsUG9zaXRpb24pO1xuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZGF0YUVudHJ5LCBpbmRleCkge1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBwcm9wcy5zdGFydEFuZ2xlICsgZGF0YUVudHJ5LnN0YXJ0T2Zmc2V0O1xuICAgICAgdmFyIGhhbGZBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkYXRhRW50cnkuZGVncmVlcyAvIDI7XG4gICAgICB2YXIgaGFsZkFuZ2xlUmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnMoaGFsZkFuZ2xlKTtcbiAgICAgIHZhciBkeCA9IE1hdGguY29zKGhhbGZBbmdsZVJhZGlhbnMpICogbGFiZWxQb3NpdGlvbjtcbiAgICAgIHZhciBkeSA9IE1hdGguc2luKGhhbGZBbmdsZVJhZGlhbnMpICogbGFiZWxQb3NpdGlvbjsgLy8gVGhpcyBvYmplY3QgaXMgcGFzc2VkIGFzIHByb3BzIHRvIHRoZSBcImxhYmVsXCIgY29tcG9uZW50XG5cbiAgICAgIHZhciBsYWJlbFByb3BzID0ge1xuICAgICAgICBrZXk6IFwibGFiZWwtXCIgKyAoZGF0YUVudHJ5LmtleSB8fCBpbmRleCksXG4gICAgICAgIHg6IHByb3BzLmN4LFxuICAgICAgICB5OiBwcm9wcy5jeSxcbiAgICAgICAgZHg6IGR4LFxuICAgICAgICBkeTogZHksXG4gICAgICAgIHRleHRBbmNob3I6IGV2YWx1YXRlTGFiZWxUZXh0QW5jaG9yKHtcbiAgICAgICAgICBsaW5lV2lkdGg6IHByb3BzLmxpbmVXaWR0aCxcbiAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBwcm9wcy5sYWJlbFBvc2l0aW9uLFxuICAgICAgICAgIGxhYmVsSG9yaXpvbnRhbFNoaWZ0OiBkeFxuICAgICAgICB9KSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICAgICAgY29sb3I6IGRhdGFFbnRyeS5jb2xvcixcbiAgICAgICAgc3R5bGU6IHByb3BzLmxhYmVsU3R5bGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVuZGVyTGFiZWxJdGVtKHByb3BzLmxhYmVsLCBsYWJlbFByb3BzLCBkYXRhRW50cnkudmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyU2VnbWVudHMoZGF0YSwgcHJvcHMsIGhpZGUpIHtcbiAgICB2YXIgc3R5bGUgPSBwcm9wcy5zZWdtZW50c1N0eWxlO1xuICAgIHZhciByZXZlYWw7XG5cbiAgICBpZiAocHJvcHMuYW5pbWF0ZSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25TdHlsZSA9IG1ha2VTZWdtZW50VHJhbnNpdGlvblN0eWxlKHByb3BzLmFuaW1hdGlvbkR1cmF0aW9uLCBwcm9wcy5hbmltYXRpb25FYXNpbmcsIHN0eWxlKTtcbiAgICAgIHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHRyYW5zaXRpb25TdHlsZSk7XG4gICAgfSAvLyBIaWRlL3JldmVhbCB0aGUgc2VnbWVudD9cblxuXG4gICAgaWYgKGhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldmVhbCA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMucmV2ZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV2ZWFsID0gcHJvcHMucmV2ZWFsO1xuICAgIH0gZWxzZSBpZiAoaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldmVhbCA9IDEwMDtcbiAgICB9XG5cbiAgICB2YXIgcGF0aHMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZGF0YUVudHJ5LCBpbmRleCkge1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBwcm9wcy5zdGFydEFuZ2xlICsgZGF0YUVudHJ5LnN0YXJ0T2Zmc2V0O1xuICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoLCB7XG4gICAgICAgIGtleTogZGF0YUVudHJ5LmtleSB8fCBpbmRleCxcbiAgICAgICAgY3g6IHByb3BzLmN4LFxuICAgICAgICBjeTogcHJvcHMuY3ksXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGxlbmd0aEFuZ2xlOiBkYXRhRW50cnkuZGVncmVlcyxcbiAgICAgICAgcmFkaXVzOiBwcm9wcy5yYWRpdXMsXG4gICAgICAgIGxpbmVXaWR0aDogZXh0cmFjdFBlcmNlbnRhZ2UocHJvcHMucmFkaXVzLCBwcm9wcy5saW5lV2lkdGgpLFxuICAgICAgICByZXZlYWw6IHJldmVhbCxcbiAgICAgICAgdGl0bGU6IGRhdGFFbnRyeS50aXRsZSxcbiAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCBkYXRhRW50cnkuc3R5bGUpLFxuICAgICAgICBzdHJva2U6IGRhdGFFbnRyeS5jb2xvcixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogcHJvcHMucm91bmRlZCA/ICdyb3VuZCcgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBvbk1vdXNlT3ZlcjogcHJvcHMub25Nb3VzZU92ZXIgJiYgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMub25Nb3VzZU92ZXIoZSwgcHJvcHMuZGF0YSwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlT3V0OiBwcm9wcy5vbk1vdXNlT3V0ICYmIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLm9uTW91c2VPdXQoZSwgcHJvcHMuZGF0YSwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBwcm9wcy5vbkNsaWNrICYmIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLm9uQ2xpY2soZSwgcHJvcHMuZGF0YSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChwcm9wcy5iYWNrZ3JvdW5kKSB7XG4gICAgICBwYXRocy51bnNoaWZ0KFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RNaW5pbWFsUGllQ2hhcnRQYXRoLCB7XG4gICAgICAgIGtleTogXCJiZ1wiLFxuICAgICAgICBjeDogcHJvcHMuY3gsXG4gICAgICAgIGN5OiBwcm9wcy5jeSxcbiAgICAgICAgc3RhcnRBbmdsZTogcHJvcHMuc3RhcnRBbmdsZSxcbiAgICAgICAgbGVuZ3RoQW5nbGU6IHByb3BzLmxlbmd0aEFuZ2xlLFxuICAgICAgICByYWRpdXM6IHByb3BzLnJhZGl1cyxcbiAgICAgICAgbGluZVdpZHRoOiBleHRyYWN0UGVyY2VudGFnZShwcm9wcy5yYWRpdXMsIHByb3BzLmxpbmVXaWR0aCksXG4gICAgICAgIHN0cm9rZTogcHJvcHMuYmFja2dyb3VuZCxcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogcHJvcHMucm91bmRlZCA/ICdyb3VuZCcgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG5cbiAgdmFyIFJlYWN0TWluaW1hbFBpZUNoYXJ0ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFJlYWN0TWluaW1hbFBpZUNoYXJ0LCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJlYWN0TWluaW1hbFBpZUNoYXJ0KHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBfdGhpcy5oaWRlU2VnbWVudHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFJlYWN0TWluaW1hbFBpZUNoYXJ0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmFuaW1hdGUgPT09IHRydWUgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbEFuaW1hdGlvblRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuaW5pdGlhbEFuaW1hdGlvblRpbWVySWQgPSBudWxsO1xuICAgICAgICAgIF90aGlzMi5pbml0aWFsQW5pbWF0aW9uUkFGSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLmluaXRpYWxBbmltYXRpb25SQUZJZCA9IG51bGw7XG5cbiAgICAgICAgICAgIF90aGlzMi5zdGFydEFuaW1hdGlvbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsQW5pbWF0aW9uVGltZXJJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbml0aWFsQW5pbWF0aW9uVGltZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxBbmltYXRpb25SQUZJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmluaXRpYWxBbmltYXRpb25SQUZJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5zdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKCkge1xuICAgICAgdGhpcy5oaWRlU2VnbWVudHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4dGVuZGVkRGF0YSA9IGV4dGVuZERhdGEodGhpcy5wcm9wcyk7XG4gICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlXG4gICAgICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgICAgdmlld0JveDogZXZhbHVhdGVWaWV3Qm94U2l6ZSh0aGlzLnByb3BzLnJhdGlvLCBWSUVXQk9YX1NJWkUpLFxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9XG4gICAgICB9LCByZW5kZXJTZWdtZW50cyhleHRlbmRlZERhdGEsIHRoaXMucHJvcHMsIHRoaXMuaGlkZVNlZ21lbnRzKSwgdGhpcy5wcm9wcy5sYWJlbCAmJiByZW5kZXJMYWJlbHMoZXh0ZW5kZWREYXRhLCB0aGlzLnByb3BzKSwgdGhpcy5wcm9wcy5pbmplY3RTdmcgJiYgdGhpcy5wcm9wcy5pbmplY3RTdmcoKSksIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3RNaW5pbWFsUGllQ2hhcnQ7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcbiAgUmVhY3RNaW5pbWFsUGllQ2hhcnQuZGlzcGxheU5hbWUgPSAnUmVhY3RNaW5pbWFsUGllQ2hhcnQnO1xuICBSZWFjdE1pbmltYWxQaWVDaGFydC5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogZGF0YVByb3BUeXBlLFxuICAgIGN4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGN5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJhdGlvOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHRvdGFsVmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHN0eWxlOiBzdHlsZVByb3BUeXBlLFxuICAgIHNlZ21lbnRzU3R5bGU6IHN0eWxlUHJvcFR5cGUsXG4gICAgYmFja2dyb3VuZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzdGFydEFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxlbmd0aEFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBhZGRpbmdBbmdsZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBsaW5lV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJvdW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGFuaW1hdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGFuaW1hdGlvbkVhc2luZzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICByZXZlYWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGluamVjdFN2ZzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgbGFiZWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgICBsYWJlbFBvc2l0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxhYmVsU3R5bGU6IHN0eWxlUHJvcFR5cGUsXG4gICAgb25Nb3VzZU92ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VPdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXG4gIH07XG4gIFJlYWN0TWluaW1hbFBpZUNoYXJ0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBjeDogVklFV0JPWF9IQUxGX1NJWkUsXG4gICAgY3k6IFZJRVdCT1hfSEFMRl9TSVpFLFxuICAgIHJhdGlvOiAxLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgbGVuZ3RoQW5nbGU6IDM2MCxcbiAgICBwYWRkaW5nQW5nbGU6IDAsXG4gICAgbGluZVdpZHRoOiAxMDAsXG4gICAgcmFkaXVzOiBWSUVXQk9YX0hBTEZfU0laRSxcbiAgICByb3VuZGVkOiBmYWxzZSxcbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICBsYWJlbDogZmFsc2UsXG4gICAgbGFiZWxQb3NpdGlvbjogNTAsXG4gICAgb25Nb3VzZU92ZXI6IHVuZGVmaW5lZCxcbiAgICBvbk1vdXNlT3V0OiB1bmRlZmluZWQsXG4gICAgb25DbGljazogdW5kZWZpbmVkXG4gIH07XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gUmVhY3RNaW5pbWFsUGllQ2hhcnQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-minimal-pie-chart/dist/index.js\n");

/***/ })

}]);